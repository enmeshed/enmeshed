import { callInjectDependencies, callProviderInitializer } from './Provider'
import { setDependencyNode } from './Resource'

debug = require("debug")("@enmeshed/alpha")

class SetupContext:
  constructor(resolutionContext, dependencyNode, provider, namespace) ->
    this.resolutionContext = resolutionContext
    this.dependencyNode = dependencyNode
    this.provider = provider
    this.namespace = namespace

  getNameArg() ->
    this.resolutionContext.nameArg

export setup(namespace, provider, resolutionContext, isTransient) -/>
  debug("Namespace", namespace.name, "setup", resolutionContext.name)
  { Dependencies } = namespace.constructor

  // Create associated deptree node
  node = new (namespace.constructor.DependencyNode)()
  node.setResolutionContext(resolutionContext)
  node.provider = provider
  node.isTransient = isTransient
  if not isTransient:
    node.namespace = namespace

  setupContext = new SetupContext(resolutionContext, node, provider, namespace)
  // Get collection of dependencies from resource provider
  deps = Dependencies.of(provider)
  // Resolve deps
  { resolvedDependencies, strongRefs } <- deps.resolve(setupContext)
  // Inject into dependency node which will refcount all the deps
  node.injectDependencies(strongRefs)

  // Create the resource using injectDependencies
  try:
    debug("Namespace", namespace.name, "injectDependencies", resolutionContext.name)
    resource <- callInjectDependencies(provider, resolvedDependencies, setupContext)
    setDependencyNode(resource, node)
    debug("Namespace", namespace.name, "callInitializer", resolutionContext.name)
    <- callProviderInitializer(provider, resource, setupContext)
    debug("Namespace", namespace.name, "calledInitializer", resolutionContext.name)
    resource
  catch err:
    // If dependency injection fails, cleanup references we took during init
    node.teardown().catch((err) -> console.error("Error during destructor cascade", err))
    throw err
