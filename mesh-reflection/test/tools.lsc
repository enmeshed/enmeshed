import { Service, Provider, DataSource } from '..'
deferred = require('p-defer')

debug = require('debug')('mesh-reflection:test')

export class TestDataSource extends DataSource:
  start(dom): void ->
    super.start(dom)

  injectEnvironment(name) ->
    this.domain._createEnvironment(name)

  injectServiceTemplate(name, tmpl): void ->
    this.domain._setEntityTemplate('service', name, tmpl)

  injectProviderTemplate(name, tmpl): void ->
    this.domain._setEntityTemplate('provider', name, tmpl)

  injectService(envName, svcName, data): Service ->
    env = this.domain.getEnvironment(envName)
    env._createService(svcName, data)

  injectProvider(envName, provName, data): Provider ->
    env = this.domain.getEnvironment(envName)
    env._createProvider(provName, data)

  injectProviderMap(envName, map): void ->
    env = this.domain.getEnvironment(envName)
    env._setProviderMap(map)

export awaitUpdate(environment) ->
  debug("awaiting update for environment", environment.name)
  def = deferred()
  listener = (didTimeout) ->
    debug("awaitUpdate listener, timeout=", didTimeout)
    clearTimeout(timer)
    environment.off('providersChanged', listener)
    environment.off('servicesChanged', listener)
    def.resolve(undefined)

  timer = setTimeout(-> listener(true), 1000)

  environment.on('providersChanged', listener)
  environment.on('servicesChanged', listener)

  def.promise

export class UpdateCollector:
  providersChanged = {}
  servicesChanged = {}

  constructor(environment) ->
    this.environment = environment
    environment.on('providerChanged', this.pc)
    environment.on('serviceChanged', this.sc)

  pc(prov) =>
    this.providersChanged[prov.name] = prov

  sc(sv) =>
    this.servicesChanged[sv.name] = sv

  done() ->
    this.environment.off('providerChanged', this.pc)
    this.environment.off('serviceChanged', this.sc)
