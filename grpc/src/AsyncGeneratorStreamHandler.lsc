import { Repeater } from '@repeaterjs/repeater'
import merge from 'mergeiterator'

isPromise = require('is-promise')
isAsyncIterable = require('is-async-iterable')

// async function* stream(AsyncIterable inputStream)
// You can yield:
//    null = no-op
//    some object = translate into gRPC message

transformInputStream(stream) ->
  new Repeater! (push, stop) -/>

    errHandler = (err): void -> stop(err)
    // End of read stream
    endHandler = (): void -> stop()
    // Data packet
    packetHandler = (packet): void -> push(packet)

    stream.on('error', errHandler)
    stream.on('end', endHandler)
    stream.on('data', packetHandler)

    <- stop

    stream.off('error', errHandler)
    stream.off('end', endHandler)
    stream.off('data', packetHandler)

asyncIteratorFromPromise(pr, transform) ->
  new Repeater! (push, stop) -/>
    try:
      result <- pr
      push(if transform: transform(result) else: result)
    catch err:
      stop(err)
    stop()

asyncGeneratorFromValue(val) -*/>
  yield val

transformPromiseOutput(po) ->
  match po:
    | ~isAsyncIterable(): po
    | else: asyncGeneratorFromValue(po)

transformAnyOutput(o) ->
  match o:
    | ~isAsyncIterable(): o
    | ~isPromise(): asyncIteratorFromPromise(o, transformPromiseOutput)
    | else: asyncGeneratorFromValue(o)

// The output iterable is an async iterable returning items of the following
// kinds:
// - AsyncIterables, which are merged
// - Promises, which are awaited and the resulting object handled according
//  to this list
// - Other kinds of objects, which are turned into async iterables that yield themselves
transformOutputIterable(iterable) ->
  merge(map(iterable, transformAnyOutput))



handleStream(stream, asyncGenerator): void -/>
  for await answer of asyncHandler(inputIterable, stream):
    if answer == null:
      continue
    elif

export class StreamHandler:
  constructor(stream) ->
    this.stream = stream

  // Create a stream handler on the fly with given callbacks.
  static with(callbacks) ->
    next = new this(null)
    Object.assign(next, callbacks)
    next

  marshalError(err) -> err

  // Hangs up this end of the stream, indicating no more data will be sent.
  // If the `err` argument exists, the stream will instead end with an
  // error condition.
  end(err) ->
    if err:
      this._iFailed = true
      this.stream.emit('error', this.marshalError(err))
    else:
      this.stream.end()
      // if(
      //   this.stream.writable
      //   // XXX: It may be that the peer hung up BOTH ends of the stream,
      //   // for example if the peer process was killed at the OS level.
      //   // gRPC does not handle this well and still tries to write a final
      //   // packet, crashing the whole app.
      //   //
      //   // Dig into the innards here and verify this isn't the case.
      //   and this.stream.call?.stream?.writable
      // ):
      //   this.stream.end()
      // else:
      //   console.error("wtf stream not writeable", this.stream.call.stream)

  // Writes data to the stream. Data must be an object matching the appropriate
  // protobuf.
  write(data) ->
    this.stream.write(data)

  // Handle an error. Any error automatically closes the stream, so it is
  // not necessary to close the stream in the handler.
  // The isInternal argument is `true` if the error was generated by
  // user code on this side of the stream.
  error(err, isInternal: boolean): void -> return

  // Called when the stream is opened, before any incoming data is processed.
  // The stream is writeable at this point; metadata can be sent as well as
  // initial greetings.
  start(stream): void -> return

  // Called when the other end of the stream hangs up, indicating no more
  // data will be received on this end. It is still OK to write responses
  // to the stream at this point.
  hangup(): void -> return

  // Called when receiving a packet. If this method returns a Promise,
  // it is treated as asynchronously producing a response which will be
  // written to the stream. Otherwise it is treated as a synchronous
  // event handler
  data(packet) -> return

  // A promise that is settled when the stream is closed.
  closedPromise() ->
    // Already closed!
    err = this.getError()
    if err:
      return Promise.reject(err)
    elif this.isClosed():
      return Promise.resolve(this)

    // Defer
    if not this._doneDeferred: this._doneDeferred = deferred()
    this._doneDeferred.promise

  // True when both ends of the stream have hung up, or an error occurred.
  isClosed() ->
    if this._error or (this._end and this._finish): true else: false

  // True when any error occured.
  getError() -> this._error

  // Internal event processing.
  _internal(): void ->
    if this._doneDeferred:
      if this._error:
        this._doneDeferred.reject(this._error)
      elif this._end and this._finish:
        this._doneDeferred.resolve(this)


export handleStream(stream, handler: StreamHandler): void ->
  handler.stream = stream

  stream.on('error', (err): void ->
    handler._error = err

    // XXX: Google's grpc.js doesn't do any client-side error handling.
    // The only way to indicate an uncaught client side error is to
    // cancel the gRPC call.
    if handler._isClient:
      // console.log("cancelling call due to error")
      stream.cancel()

    if not handler._iFailed:
      handler.error(err, false)
    else:
      handler.error(err, true)
    handler._internal()
  )

  handler.start(stream)

  stream.on('data', (packet): void ->
    let hres
    try:
      now hres = handler.data(packet, stream)
    catch err:
      handler.end(err)
      return

    // Handler may be sync or async. If it's a promise, handle it
    if isThenable(hres):
      hres
        .then! (val): void ->
          if val and typeof(val) == "object":
            stream.write(val)
        .catch! (err): void ->
          handler.end(err)
  )

  stream.on('end', ->
    handler._end = true
    // Remote hangup
    handler.hangup()
    handler._internal()
  )

  stream.on('finish', ->
    handler._finish = true
    handler._internal()
  )
