import { Protocols, ServerEnhancer, ClientEnhancer, StreamHandler } from '..'
grpc = require('@grpc/grpc-js')

let protos = null
let server = null
let client = null

class BidiStreamHandler extends StreamHandler:
  start() ->
    console.log("BidiStreamHandler: started")
    this.write({ message: 'welcome' })
  error(err, isInternal) ->
    console.error(isInternal, err)
  data(packet) -/>
    { message } = packet
    console.log("BidiStreamHandler data: ", message)
    if message == 'fail':
      throw new Error('failed call')
    else:
      { message: 'echo: ' + message }
  hangup() ->
    console.log("BidiStreamHandler: They hung up")
    this.end()

// Launch grpc server
beforeAll! -/>
  try:
    now protos = new Protocols()
    protos.setProtoPath('test')
    protos.require('TestService')
    protos.load()

    now server = new ServerEnhancer(new grpc.Server())
    server.addService(protos.service('TestService'), {
      bidiStream: BidiStreamHandler
    })
    <- server.bind('0.0.0.0:31338', grpc.ServerCredentials.createInsecure())
    server.start()
    console.log("started grpc server")

    now client = new ClientEnhancer(protos.client('TestService', '127.0.0.1:31338', grpc.credentials.createInsecure()))
  catch err:
    console.error(err)

// Close grpc server
afterAll! ->
  console.log("stopping grpc server")
  server.shutdown()

test! "bidiStream client error", -/>
  handler = client.bidiStream(StreamHandler.with({
    error(err, isInternal) ->
      console.error("bidiStream client error:", isInternal, err)
    data(packet) ->
      this.end(new Error("client stream fail"))
  }))

  try:
    await handler.closedPromise()
    expect(1).toBe(0)
  catch err:
    expect(err.message).toBe("client stream fail")
